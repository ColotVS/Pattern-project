package Composite;

public class Composite {    //structural pattern, Структурный паттерн
    //Паттерн проектирования «Компоновщик» / «Composite»


    //Проблема
    //Предоставить клиенту единообразный доступ к листовым и составным элементам древовидной структуры.

    //Структура
    //Составной шаблон предназначен для того, чтобы позволять обрабатывать отдельные объекты и композиции объектов,
    //или “композиты”, одинаковым образом.

    //Его можно рассматривать как древовидную структуру, состоящую из типов, наследующих базовый тип,
    //и он может представлять отдельную часть или целую иерархию объектов.

    //Мы можем разбить этот шаблон на:

    //component – это базовый интерфейс для всех объектов в композиции. Это должен быть либо интерфейс,
    //либо абстрактный класс с общими методами для управления дочерними композитами.

    //leaf – реализует поведение базового компонента по умолчанию. Он не содержит ссылок на другие объекты.

    //сomposite – содержит конечные элементы.
    //Он реализует методы базового компонента и определяет операции, связанные с дочерними компонентами.

    //client – имеет доступ к элементам композиции с помощью базового объекта component.


    //Практический пример
    //Теперь давайте углубимся в реализацию.
    //Предположим, мы хотим построить иерархическую структуру отделов в компании.

    //3.1. Базовый компонент
    //В качестве объекта component мы определим простой интерфейс отдела:

    //public interface Department {
    //    void printDepartmentName();
    //}


    //3.2. Leafs
    //Для конечных компонентов давайте определим классы для финансовых отделов и отделов продаж:

    //public class FinancialDepartment implements Department {
    //
    //    private Integer id;
    //    private String name;
    //
    //    public void printDepartmentName() {
    //        System.out.println(getClass().getSimpleName());
    //    }
    //
    //    // standard constructor, getters, setters
    //}

    //Второй конечный класс, SalesDepartment, похож:

    //public class SalesDepartment implements Department {
    //
    //    private Integer id;
    //    private String name;
    //
    //    public void printDepartmentName() {
    //        System.out.println(getClass().getSimpleName());
    //    }
    //
    //    // standard constructor, getters, setters
    //}

    //Оба класса реализуют метод printDepartmentName() из базового компонента, где они печатают имена классов для каждого из них.

}
